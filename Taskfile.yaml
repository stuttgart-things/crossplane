---
version: 3
vars:
  PROJECT:
    sh: echo ${PROJECT}
  BRANCH:
    sh: if [ $(git rev-parse --abbrev-ref HEAD) != "main" ]; then echo $(git rev-parse --abbrev-ref HEAD); else echo main ; fi
  CROSSPLANE_PACKAGE_REGISTRY: ghcr.io
  DAGGER_CROSSPLANE_MODULE: github.com/stuttgart-things/dagger/crossplane #../dagger/crossplane #github.com/stuttgart-things/dagger/crossplane
  DAGGER_CROSSPLANE_MODULE_VERSION: v0.59.0

includes:
  git:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/git/git.yaml
  crossplane:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/configuration/crossplane.yaml
  k2n:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/configuration/k2n.yaml

tasks:
  push-configuration-package:
    desc: Push crossplane configuration package
    cmds:
      - |
        set -e

        CONFIGURATION_PACKAGE_PATH={{ .ALL_CONFIGURATION_PACKAGES }}
        CONFIGURATION_PACKAGE=$(basename "${CONFIGURATION_PACKAGE_PATH}")

        IMAGE="{{ .DESTINATION }}/${CONFIGURATION_PACKAGE}"

        echo "üîç Checking existing versions for ${IMAGE}..."

        TAGS=$(oras repo tags "${IMAGE}" 2>/dev/null || true)

        SEMVER_TAGS=$(echo "$TAGS" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)

        if [ -z "$SEMVER_TAGS" ]; then
          echo "‚ö†Ô∏è  No released versions found"
          DEFAULT_TAG="v0.1.0"
        else
          echo
          echo "üì¶ Released versions:"
          echo "$SEMVER_TAGS" | sort -V | sed 's/^/  - /'

          LATEST=$(echo "$SEMVER_TAGS" | sort -V | tail -n1)

          echo
          echo "‚úÖ Latest released version: ${LATEST}"

          DEFAULT_TAG=$(
            echo "$LATEST" | awk -F. '{
              sub(/^v/,"",$1);
              printf("v%d.%d.0\n",$1,$2+1)
            }'
          )
        fi

        echo
        TAG=$(gum input \
          --prompt "Tag: " \
          --value "${DEFAULT_TAG}")

        echo
        echo "üöÄ Pushing configuration package:"
        echo "  Package : ${CONFIGURATION_PACKAGE_PATH}"
        echo "  Image   : ${IMAGE}"
        echo "  Tag     : ${TAG}"

        dagger call \
          -m {{ .DAGGER_CROSSPLANE_MODULE }}@{{ .DAGGER_CROSSPLANE_MODULE_VERSION }} \
          push \
          --src {{ .SOURCE_FOLDER }}/${CONFIGURATION_PACKAGE_PATH} \
          --progress plain \
          --username={{ .USER }} \
          --password=env:GITHUB_TOKEN \
          --registry={{ .CROSSPLANE_PACKAGE_REGISTRY }} \
          --destination="${IMAGE}:${TAG}"
    vars:
      DESTINATION: "{{ .CROSSPLANE_PACKAGE_REGISTRY }}/stuttgart-things/crossplane"
      USER: stuttgart-things
      SOURCE_FOLDER: "./configurations"
      ALL_CONFIGURATION_PACKAGES:
        sh: |
          find {{ .SOURCE_FOLDER }}/k8s {{ .SOURCE_FOLDER }}/cluster {{ .SOURCE_FOLDER }}/infra {{ .SOURCE_FOLDER }}/config {{ .SOURCE_FOLDER }}/terraform {{ .SOURCE_FOLDER }}/apps \
            -mindepth 1 -maxdepth 1 -type d | \
            sed "s|^\./configurations/||" | \
            sort | \
            gum choose

  push-module:
    desc: Push KCL module to OCI registry
    cmds:
      - |
        set -e

        MODULE_PATH={{ .ALL_MODULES }}
        MODULE=$(basename "${MODULE_PATH}")

        IMAGE="{{ .DESTINATION }}/${MODULE}"

        echo "üîç Checking existing versions for ${IMAGE}..."

        TAGS=$(oras repo tags "${IMAGE}" 2>/dev/null || true)

        SEMVER_TAGS=$(echo "$TAGS" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)

        if [ -z "$SEMVER_TAGS" ]; then
          echo "‚ö†Ô∏è  No released versions found"
          DEFAULT_TAG="v0.1.0"
        else
          echo
          echo "üì¶ Released versions:"
          echo "$SEMVER_TAGS" | sort -V | sed 's/^/  - /'

          LATEST=$(echo "$SEMVER_TAGS" | sort -V | tail -n1)

          echo
          echo "‚úÖ Latest released version: ${LATEST}"

          DEFAULT_TAG=$(
            echo "$LATEST" | awk -F. '{
              sub(/^v/,"",$1);
              printf("v%d.%d.0\n",$1,$2+1)
            }'
          )
        fi

        echo
        TAG=$(gum input \
          --prompt "Tag: " \
          --value "${DEFAULT_TAG}")

        echo
        echo "üöÄ Pushing KCL module:"
        echo "  Module : ${MODULE_PATH}"
        echo "  Image  : ${IMAGE}"
        echo "  Tag    : ${TAG}"

        cd "${MODULE_PATH}"
        kcl mod push "oci://${IMAGE}:${TAG}" \
          --username={{ .USER }} \
          --password=${GITHUB_TOKEN}
    vars:
      DESTINATION: "{{ .CROSSPLANE_PACKAGE_REGISTRY }}/stuttgart-things/xplane"
      USER: stuttgart-things
      ALL_MODULES:
        sh: |
          find . -maxdepth 1 -type d -name "xplane-*" | \
            sed 's|^\./||' | \
            sort | \
            gum choose

  merge-environment:
    desc: Merge container-use environment into main branch
    cmds:
      - |
        echo "Available environments:"
        ENVIRONMENTS=$(container-use list | tail -n +2 | awk '{print $1}' | grep -v "^$")
        if [ -z "$ENVIRONMENTS" ]; then
          echo "No environments found. Please create an environment first."
          exit 1
        fi

        echo "$ENVIRONMENTS"
        echo ""
        echo "Enter environment ID to merge:"
        read ENV_ID

        if [ -z "$ENV_ID" ]; then
          echo "No environment ID provided. Exiting."
          exit 1
        fi

        echo "Merging environment: $ENV_ID"

        # Checkout environment
        container-use checkout $ENV_ID

        # Check status
        echo "Environment status:"
        git status

        # Switch to main and merge
        git checkout main
        git merge cu-$ENV_ID

        # Push changes
        git push origin main

        echo "‚úÖ Environment $ENV_ID successfully merged into main!"
        echo ""
        echo "üîç View logs: container-use log $ENV_ID"
        echo "üèóÔ∏è  Checkout: container-use checkout $ENV_ID"

  merge-environment-auto:
    desc: Merge specific container-use environment into main (with ENV_ID parameter)
    cmds:
      - |
        if [ -z "{{ .ENV_ID }}" ]; then
          echo "‚ùå Error: ENV_ID not provided"
          echo "Usage: task merge-environment-auto ENV_ID=your-env-id"
          exit 1
        fi

        echo "üîÑ Merging environment: {{ .ENV_ID }}"

        # Checkout environment
        container-use checkout {{ .ENV_ID }}

        # Check status
        echo "üìä Environment status:"
        git status

        # Switch to main and merge
        echo "üîÄ Switching to main and merging..."
        git checkout main
        git merge cu-{{ .ENV_ID }}

        # Push changes
        echo "üöÄ Pushing changes..."
        git push origin main

        echo "‚úÖ Environment {{ .ENV_ID }} successfully merged into main!"
        echo ""
        echo "üîç View logs: container-use log {{ .ENV_ID }}"
        echo "üèóÔ∏è  Checkout: container-use checkout {{ .ENV_ID }}"
    vars:
      ENV_ID: '{{ .ENV_ID | default "" }}'

  merge-environment-pr:
    desc: Merge container-use environment via Pull Request
    cmds:
      - |
        echo "Available environments:"
        ENVIRONMENTS=$(container-use list | tail -n +2 | awk '{print $1}' | grep -v "^$")
        if [ -z "$ENVIRONMENTS" ]; then
          echo "No environments found. Please create an environment first."
          exit 1
        fi

        echo "$ENVIRONMENTS"
        echo ""
        echo "Enter environment ID for PR:"
        read ENV_ID

        if [ -z "$ENV_ID" ]; then
          echo "No environment ID provided. Exiting."
          exit 1
        fi

        echo "Creating PR for environment: $ENV_ID"

        # Checkout environment
        container-use checkout $ENV_ID

        # Create PR title and body
        TITLE="feat: merge container-use environment $ENV_ID"
        BODY="Automated merge of container-use environment: $ENV_ID

        Environment Changes:
        - $(git log --oneline cu-$ENV_ID ^main | head -5)

        üîç View logs: \`container-use log $ENV_ID\`
        üèóÔ∏è  Checkout: \`container-use checkout $ENV_ID\`"

        # Create PR from environment branch to main
        gh pr create --base main --head cu-$ENV_ID --title "$TITLE" --body "$BODY"

        echo "‚úÖ Pull Request created successfully!"
        echo "üîç View logs: container-use log $ENV_ID"
        echo "üèóÔ∏è  Checkout: container-use checkout $ENV_ID"

  do:
    desc: Select a task to run
    cmds:
      - |
        # Extract task names (keep internal colons, remove only trailing colon)
        task_name=$(task -l | awk '/^\*/ {print $2}' | sed 's/:$//' | gum choose)

        # Run the selected task
        [ -n "$task_name" ] && task "$task_name"

  apply-crossplane-packages:
    desc: Manage Crossplane functions and configurations using Dagger Kubernetes module
    vars:
      MODULE: github.com/stuttgart-things/dagger/kubernetes
      VERSION: v0.57.0
      OPERATION:
        sh: |
          if [[ -n "${OPERATION:-}" ]]; then
            if gum confirm --default=true "OPERATION is set to '${OPERATION}'. Keep it?"; then
              echo "${OPERATION}"
            else
              gum choose "apply" "delete"
            fi
          else
            gum choose "apply" "delete"
          fi
      PACKAGE_TYPE:
        sh: |
          gum choose \
            "Functions" \
            "Configurations" \
            "Both"
      SELECTED_FUNCTIONS:
        sh: |
          package_type="{{ .PACKAGE_TYPE }}"
          if [[ "$package_type" == "Functions" || "$package_type" == "Both" ]]; then
            gum choose --no-limit --header="Select Crossplane Functions:" \
              "function-auto-ready" \
              "function-go-templating" \
              "function-kcl" \
              "function-patch-and-transform"
          fi
      SELECTED_CONFIGURATIONS:
        sh: |
          package_type="{{ .PACKAGE_TYPE }}"
          if [[ "$package_type" == "Configurations" || "$package_type" == "Both" ]]; then
            gum choose --no-limit --header="Select Crossplane Configurations:" \
              "cloud-config" \
              "volume-claim"
          fi
      KUBECONFIG_PATH:
        sh: |
          if [[ -n "${KUBECONFIG_PATH:-}" ]]; then
            if gum confirm --default=true "KUBECONFIG_PATH is set to '${KUBECONFIG_PATH}'. Keep it?"; then
              echo "${KUBECONFIG_PATH}"
            else
              if gum confirm "Use current KUBECONFIG (${KUBECONFIG:-~/.kube/config})?"; then
                echo "${KUBECONFIG:-~/.kube/config}"
              else
                gum file ~/.kube/
              fi
            fi
          else
            if gum confirm "Use current KUBECONFIG (${KUBECONFIG:-~/.kube/config})?"; then
              echo "${KUBECONFIG:-~/.kube/config}"
            else
              gum file ~/.kube/
            fi
          fi
      KUBECONFIG_FILE:
        sh: |
          path="{{ .KUBECONFIG_PATH }}"
          eval echo "$path"
    cmds:
      - |
        selected_functions="{{ .SELECTED_FUNCTIONS }}"
        selected_configurations="{{ .SELECTED_CONFIGURATIONS }}"

        if [[ -z "$selected_functions" && -z "$selected_configurations" ]]; then
          echo "Error: No packages selected"
          exit 1
        fi

        echo "Executing kubectl operation with the following configuration:"
        echo "  Operation: {{ .OPERATION }}"

        if [[ -n "$selected_functions" ]]; then
          echo "  Selected Functions:"
          while IFS= read -r func; do
            [[ -n "$func" ]] && echo "    - $func"
          done <<< "$selected_functions"
        fi

        if [[ -n "$selected_configurations" ]]; then
          echo "  Selected Configurations:"
          while IFS= read -r config; do
            [[ -n "$config" ]] && echo "    - $config"
          done <<< "$selected_configurations"
        fi

        echo "  Kubeconfig: {{ .KUBECONFIG_FILE }}"
        echo ""

        if [[ ! -f "{{ .KUBECONFIG_FILE }}" ]]; then
          echo "Error: Kubeconfig file not found at {{ .KUBECONFIG_FILE }}"
          exit 1
        fi

        operation="{{ .OPERATION }}"

        if gum confirm "Proceed with kubectl $operation for selected packages?"; then

          # Process Functions
          if [[ -n "$selected_functions" ]]; then
            echo ""
            echo "=== Processing Functions ==="
            while IFS= read -r function_name; do
              [[ -z "$function_name" ]] && continue

              func_url="https://raw.githubusercontent.com/stuttgart-things/crossplane/refs/heads/main/packages/functions/${function_name}.yaml"

              echo ""
              echo "Processing function: $function_name..."

              dagger call -m {{ .MODULE }}@{{ .VERSION }} kubectl \
                --operation "$operation" \
                --url-source "$func_url" \
                --kube-config file://{{ .KUBECONFIG_FILE }}

              if [[ $? -eq 0 ]]; then
                echo "‚úì Function $function_name $operation completed successfully!"
              else
                echo "‚úó Function $function_name $operation failed!"
                exit 1
              fi
            done <<< "$selected_functions"
          fi

          # Process Configurations
          if [[ -n "$selected_configurations" ]]; then
            echo ""
            echo "=== Processing Configurations ==="
            while IFS= read -r config_name; do
              [[ -z "$config_name" ]] && continue

              config_url="https://raw.githubusercontent.com/stuttgart-things/crossplane/refs/heads/main/packages/configurations/${config_name}.yaml"

              echo ""
              echo "Processing configuration: $config_name..."

              dagger call -m {{ .MODULE }}@{{ .VERSION }} kubectl \
                --operation "$operation" \
                --url-source "$config_url" \
                --kube-config file://{{ .KUBECONFIG_FILE }}

              if [[ $? -eq 0 ]]; then
                echo "‚úì Configuration $config_name $operation completed successfully!"
              else
                echo "‚úó Configuration $config_name $operation failed!"
                exit 1
              fi
            done <<< "$selected_configurations"
          fi

          echo ""
          echo "‚úì All selected packages processed successfully!"
        else
          echo "Operation cancelled."
          exit 0
        fi
