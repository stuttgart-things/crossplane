---
version: 3
vars:
  PROJECT:
    sh: echo ${PROJECT}
  BRANCH:
    sh: if [ $(git rev-parse --abbrev-ref HEAD) != "main" ]; then echo $(git rev-parse --abbrev-ref HEAD); else echo main ; fi
  CROSSPLANE_PACKAGE_REGISTRY: ghcr.io
  DAGGER_CROSSPLANE_MODULE: github.com/stuttgart-things/dagger/crossplane #../dagger/crossplane #github.com/stuttgart-things/dagger/crossplane
  DAGGER_CROSSPLANE_MODULE_VERSION: v0.59.0

includes:
  git:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/git/git.yaml
  crossplane:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/configuration/crossplane.yaml
  k2n:
    taskfile: https://raw.githubusercontent.com/stuttgart-things/tasks/refs/heads/main/configuration/k2n.yaml

tasks:
  create-new-configuration:
    desc: Interactive wizard-style generation with smart defaults
    vars:
      BLUEPRINT_CROSSPLANE_MODULE: github.com/stuttgart-things/blueprints/crossplane-configuration
      BLUEPRINT_CROSSPLANE_MODULE_VERSION: "@v1.35.0"
    cmds:
      - |
        set -e  # Exit on error

        gum style --foreground 212 --bold "üöÄ Crossplane Configuration Generator"
        echo ""

        # Step 1: Get name (with validation)
        while true; do
          NAME=$(gum input --placeholder "e.g., storage-platform" --prompt "üìù Name: ")
          if [ -n "$NAME" ]; then
            break
          else
            gum style --foreground 9 "Name cannot be empty. Please try again."
          fi
        done

        # Auto-generate suggested values based on name
        GUESSED_KIND=$(echo "$NAME" | awk -F'-' '{for(i=1;i<=NF;i++){$i=toupper(substr($i,1,1)) tolower(substr($i,2))}}1' OFS='')
        GUESSED_SINGULAR=$(echo "$NAME" | sed 's/-//g')
        GUESSED_PLURAL="${GUESSED_SINGULAR}s"
        GUESSED_CLAIM="${GUESSED_KIND}Claim"

        # Step 2: Get Kind with auto-generated default
        KIND=$(gum input --placeholder "e.g., $GUESSED_KIND" --prompt "üè∑Ô∏è  Kind (PascalCase): " --value "$GUESSED_KIND")

        # Step 3: Get XRD Singular with auto-generated default
        XRD_SINGULAR=$(gum input --placeholder "e.g., $GUESSED_SINGULAR" --prompt "üì¶ XRD Singular (lowercase): " --value "$GUESSED_SINGULAR")

        # Step 4: Get XRD Plural with auto-generated default
        XRD_PLURAL=$(gum input --placeholder "e.g., $GUESSED_PLURAL" --prompt "üì¶ XRD Plural (lowercase): " --value "$GUESSED_PLURAL")

        # Auto-generate Claim name
        CLAIM_NAME="$GUESSED_CLAIM"

        # Step 5: Select base output location
        echo ""
        echo "üìÅ Select base folder for configurations:"
        BASE_FOLDER=$(gum file --directory)
        if [ -z "$BASE_FOLDER" ]; then
          gum style --foreground 9 "No folder selected. Using current directory."
          BASE_FOLDER="."
        fi

        # Create final output path
        OUTPUT_FOLDER="${BASE_FOLDER}/${NAME}"

        # Step 6: Preview
        echo ""
        gum style --border thick --border-foreground 212 --padding "1 2" --margin "1" \
          "Configuration Preview" \
          "Name: $NAME" \
          "Kind: $KIND" \
          "XRD Singular: $XRD_SINGULAR" \
          "XRD Plural: $XRD_PLURAL" \
          "Claim Name: $CLAIM_NAME" \
          "Base Folder: $BASE_FOLDER" \
          "Output: $OUTPUT_FOLDER"

        # Step 7: Confirm generation
        echo ""
        if gum confirm "Generate configuration?" --affirmative "Yes" --negative "No"; then
          echo ""
          echo "üöÄ Starting generation..."

          # Create the output folder if it doesn't exist
          mkdir -p "$OUTPUT_FOLDER"

          # Check if .configuration-defaults.yaml exists in repo root
          DEFAULTS_FILE=".configuration-defaults.yaml"

          if [ -f "$DEFAULTS_FILE" ]; then
            DEFAULTS_FLAG="--defaults-file ${DEFAULTS_FILE}"
            echo "‚úì Using defaults file: $DEFAULTS_FILE"
            echo ""
          else
            gum style --foreground 9 "‚ö†Ô∏è  Warning: .configuration-defaults.yaml not found in repo root"
            if ! gum confirm "Continue without defaults file?"; then
              gum style --foreground 9 "‚ùå Cancelled"
              exit 0
            fi
            DEFAULTS_FLAG=""
            echo ""
          fi

          # Run the generation (show output for debugging)
          echo "Running: dagger call -m {{ .BLUEPRINT_CROSSPLANE_MODULE }}{{ .BLUEPRINT_CROSSPLANE_MODULE_VERSION }} \\"
          echo "  --name \"${NAME}\" \\"
          echo "  ${DEFAULTS_FLAG} \\"
          echo "  --variables=\"name=${NAME},kind=${KIND},xrdSingular=${XRD_SINGULAR},xrdPlural=${XRD_PLURAL},claimName=${CLAIM_NAME}\" \\"
          echo "  export --path=\"${OUTPUT_FOLDER}\""
          echo ""

            if dagger call -m {{ .BLUEPRINT_CROSSPLANE_MODULE }}{{ .BLUEPRINT_CROSSPLANE_MODULE_VERSION }} create \
              --name "${NAME}" \
              ${DEFAULTS_FLAG} \
              --variables="name=${NAME},kind=${KIND},xrdSingular=${XRD_SINGULAR},xrdPlural=${XRD_PLURAL},claimName=${CLAIM_NAME}" \
              export --path="${OUTPUT_FOLDER}"; then

            echo ""
            gum style --foreground 10 --bold "‚úÖ Successfully generated!"
            echo "Output location: $OUTPUT_FOLDER"
          else
            echo ""
            gum style --foreground 9 --bold "‚ùå Generation failed!"
            echo "Check the error messages above for details."
            exit 1
          fi
        else
          echo ""
          gum style --foreground 9 "‚ùå Cancelled"
          exit 0
        fi

  push-configuration-package:
    desc: Push crossplane configuration package
    cmds:
      - |
        set -e

        CONFIGURATION_PACKAGE_PATH={{ .ALL_CONFIGURATION_PACKAGES }}
        CONFIGURATION_PACKAGE=$(basename "${CONFIGURATION_PACKAGE_PATH}")

        IMAGE="{{ .DESTINATION }}/${CONFIGURATION_PACKAGE}"

        echo "üîç Checking existing versions for ${IMAGE}..."

        TAGS=$(oras repo tags "${IMAGE}" 2>/dev/null || true)

        SEMVER_TAGS=$(echo "$TAGS" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)

        if [ -z "$SEMVER_TAGS" ]; then
          echo "‚ö†Ô∏è  No released versions found"
          DEFAULT_TAG="v0.1.0"
        else
          echo
          echo "üì¶ Released versions:"
          echo "$SEMVER_TAGS" | sort -V | sed 's/^/  - /'

          LATEST=$(echo "$SEMVER_TAGS" | sort -V | tail -n1)

          echo
          echo "‚úÖ Latest released version: ${LATEST}"

          DEFAULT_TAG=$(
            echo "$LATEST" | awk -F. '{
              sub(/^v/,"",$1);
              printf("v%d.%d.0\n",$1,$2+1)
            }'
          )
        fi

        echo
        TAG=$(gum input \
          --prompt "Tag: " \
          --value "${DEFAULT_TAG}")

        echo
        echo "üöÄ Pushing configuration package:"
        echo "  Package : ${CONFIGURATION_PACKAGE_PATH}"
        echo "  Image   : ${IMAGE}"
        echo "  Tag     : ${TAG}"

        dagger call \
          -m {{ .DAGGER_CROSSPLANE_MODULE }}@{{ .DAGGER_CROSSPLANE_MODULE_VERSION }} \
          push \
          --src {{ .SOURCE_FOLDER }}/${CONFIGURATION_PACKAGE_PATH} \
          --progress plain \
          --username={{ .USER }} \
          --password=env:GITHUB_TOKEN \
          --registry={{ .CROSSPLANE_PACKAGE_REGISTRY }} \
          --destination="${IMAGE}:${TAG}"
    vars:
      DESTINATION: "{{ .CROSSPLANE_PACKAGE_REGISTRY }}/stuttgart-things/crossplane"
      USER: stuttgart-things
      SOURCE_FOLDER: "./configurations"
      ALL_CONFIGURATION_PACKAGES:
        sh: |
          find {{ .SOURCE_FOLDER }}/k8s {{ .SOURCE_FOLDER }}/cluster {{ .SOURCE_FOLDER }}/infra {{ .SOURCE_FOLDER }}/config {{ .SOURCE_FOLDER }}/terraform {{ .SOURCE_FOLDER }}/apps \
            -mindepth 1 -maxdepth 1 -type d | \
            sed "s|^\./configurations/||" | \
            sort | \
            gum choose

  push-module:
    desc: Push KCL module to OCI registry
    cmds:
      - |
        set -e

        MODULE_PATH={{ .ALL_MODULES }}
        MODULE=$(basename "${MODULE_PATH}")

        IMAGE="{{ .DESTINATION }}/${MODULE}"

        echo "üîç Checking existing versions for ${IMAGE}..."

        TAGS=$(oras repo tags "${IMAGE}" 2>/dev/null || true)

        SEMVER_TAGS=$(echo "$TAGS" | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' || true)

        if [ -z "$SEMVER_TAGS" ]; then
          echo "‚ö†Ô∏è  No released versions found"
          DEFAULT_TAG="v0.1.0"
        else
          echo
          echo "üì¶ Released versions:"
          echo "$SEMVER_TAGS" | sort -V | sed 's/^/  - /'

          LATEST=$(echo "$SEMVER_TAGS" | sort -V | tail -n1)

          echo
          echo "‚úÖ Latest released version: ${LATEST}"

          DEFAULT_TAG=$(
            echo "$LATEST" | awk -F. '{
              sub(/^v/,"",$1);
              printf("v%d.%d.0\n",$1,$2+1)
            }'
          )
        fi

        echo
        TAG=$(gum input \
          --prompt "Tag: " \
          --value "${DEFAULT_TAG}")

        echo
        echo "üöÄ Pushing KCL module:"
        echo "  Module : ${MODULE_PATH}"
        echo "  Image  : ${IMAGE}"
        echo "  Tag    : ${TAG}"

        cd "${MODULE_PATH}"
        kcl mod push "oci://${IMAGE}:${TAG}" \
          --username={{ .USER }} \
          --password=${GITHUB_TOKEN}
    vars:
      DESTINATION: "{{ .CROSSPLANE_PACKAGE_REGISTRY }}/stuttgart-things/xplane"
      USER: stuttgart-things
      ALL_MODULES:
        sh: |
          find . -maxdepth 1 -type d -name "xplane-*" | \
            sed 's|^\./||' | \
            sort | \
            gum choose

  merge-environment:
    desc: Merge container-use environment into main branch
    cmds:
      - |
        echo "Available environments:"
        ENVIRONMENTS=$(container-use list | tail -n +2 | awk '{print $1}' | grep -v "^$")
        if [ -z "$ENVIRONMENTS" ]; then
          echo "No environments found. Please create an environment first."
          exit 1
        fi

        echo "$ENVIRONMENTS"
        echo ""
        echo "Enter environment ID to merge:"
        read ENV_ID

        if [ -z "$ENV_ID" ]; then
          echo "No environment ID provided. Exiting."
          exit 1
        fi

        echo "Merging environment: $ENV_ID"

        # Checkout environment
        container-use checkout $ENV_ID

        # Check status
        echo "Environment status:"
        git status

        # Switch to main and merge
        git checkout main
        git merge cu-$ENV_ID

        # Push changes
        git push origin main

        echo "‚úÖ Environment $ENV_ID successfully merged into main!"
        echo ""
        echo "üîç View logs: container-use log $ENV_ID"
        echo "üèóÔ∏è  Checkout: container-use checkout $ENV_ID"

  merge-environment-auto:
    desc: Merge specific container-use environment into main (with ENV_ID parameter)
    cmds:
      - |
        if [ -z "{{ .ENV_ID }}" ]; then
          echo "‚ùå Error: ENV_ID not provided"
          echo "Usage: task merge-environment-auto ENV_ID=your-env-id"
          exit 1
        fi

        echo "üîÑ Merging environment: {{ .ENV_ID }}"

        # Checkout environment
        container-use checkout {{ .ENV_ID }}

        # Check status
        echo "üìä Environment status:"
        git status

        # Switch to main and merge
        echo "üîÄ Switching to main and merging..."
        git checkout main
        git merge cu-{{ .ENV_ID }}

        # Push changes
        echo "üöÄ Pushing changes..."
        git push origin main

        echo "‚úÖ Environment {{ .ENV_ID }} successfully merged into main!"
        echo ""
        echo "üîç View logs: container-use log {{ .ENV_ID }}"
        echo "üèóÔ∏è  Checkout: container-use checkout {{ .ENV_ID }}"
    vars:
      ENV_ID: '{{ .ENV_ID | default "" }}'

  merge-environment-pr:
    desc: Merge container-use environment via Pull Request
    cmds:
      - |
        echo "Available environments:"
        ENVIRONMENTS=$(container-use list | tail -n +2 | awk '{print $1}' | grep -v "^$")
        if [ -z "$ENVIRONMENTS" ]; then
          echo "No environments found. Please create an environment first."
          exit 1
        fi

        echo "$ENVIRONMENTS"
        echo ""
        echo "Enter environment ID for PR:"
        read ENV_ID

        if [ -z "$ENV_ID" ]; then
          echo "No environment ID provided. Exiting."
          exit 1
        fi

        echo "Creating PR for environment: $ENV_ID"

        # Checkout environment
        container-use checkout $ENV_ID

        # Create PR title and body
        TITLE="feat: merge container-use environment $ENV_ID"
        BODY="Automated merge of container-use environment: $ENV_ID

        Environment Changes:
        - $(git log --oneline cu-$ENV_ID ^main | head -5)

        üîç View logs: \`container-use log $ENV_ID\`
        üèóÔ∏è  Checkout: \`container-use checkout $ENV_ID\`"

        # Create PR from environment branch to main
        gh pr create --base main --head cu-$ENV_ID --title "$TITLE" --body "$BODY"

        echo "‚úÖ Pull Request created successfully!"
        echo "üîç View logs: container-use log $ENV_ID"
        echo "üèóÔ∏è  Checkout: container-use checkout $ENV_ID"

  do:
    desc: Select a task to run
    cmds:
      - |
        # Extract task names (keep internal colons, remove only trailing colon)
        task_name=$(task -l | awk '/^\*/ {print $2}' | sed 's/:$//' | gum choose)

        # Run the selected task
        [ -n "$task_name" ] && task "$task_name"

  apply-crossplane-packages:
    desc: Manage Crossplane functions and configurations using Dagger Kubernetes module
    vars:
      MODULE: github.com/stuttgart-things/dagger/kubernetes
      VERSION: v0.57.0
      OPERATION:
        sh: |
          if [[ -n "${OPERATION:-}" ]]; then
            if gum confirm --default=true "OPERATION is set to '${OPERATION}'. Keep it?"; then
              echo "${OPERATION}"
            else
              gum choose "apply" "delete"
            fi
          else
            gum choose "apply" "delete"
          fi
      PACKAGE_TYPE:
        sh: |
          gum choose \
            "Functions" \
            "Configurations" \
            "Both"
      SELECTED_FUNCTIONS:
        sh: |
          package_type="{{ .PACKAGE_TYPE }}"
          if [[ "$package_type" == "Functions" || "$package_type" == "Both" ]]; then
            gum choose --no-limit --header="Select Crossplane Functions:" \
              "function-auto-ready" \
              "function-go-templating" \
              "function-kcl" \
              "function-patch-and-transform"
          fi
      SELECTED_CONFIGURATIONS:
        sh: |
          package_type="{{ .PACKAGE_TYPE }}"
          if [[ "$package_type" == "Configurations" || "$package_type" == "Both" ]]; then
            gum choose --no-limit --header="Select Crossplane Configurations:" \
              "cloud-config" \
              "volume-claim"
          fi
      KUBECONFIG_PATH:
        sh: |
          if [[ -n "${KUBECONFIG_PATH:-}" ]]; then
            if gum confirm --default=true "KUBECONFIG_PATH is set to '${KUBECONFIG_PATH}'. Keep it?"; then
              echo "${KUBECONFIG_PATH}"
            else
              if gum confirm "Use current KUBECONFIG (${KUBECONFIG:-~/.kube/config})?"; then
                echo "${KUBECONFIG:-~/.kube/config}"
              else
                gum file ~/.kube/
              fi
            fi
          else
            if gum confirm "Use current KUBECONFIG (${KUBECONFIG:-~/.kube/config})?"; then
              echo "${KUBECONFIG:-~/.kube/config}"
            else
              gum file ~/.kube/
            fi
          fi
      KUBECONFIG_FILE:
        sh: |
          path="{{ .KUBECONFIG_PATH }}"
          eval echo "$path"
    cmds:
      - |
        selected_functions="{{ .SELECTED_FUNCTIONS }}"
        selected_configurations="{{ .SELECTED_CONFIGURATIONS }}"

        if [[ -z "$selected_functions" && -z "$selected_configurations" ]]; then
          echo "Error: No packages selected"
          exit 1
        fi

        echo "Executing kubectl operation with the following configuration:"
        echo "  Operation: {{ .OPERATION }}"

        if [[ -n "$selected_functions" ]]; then
          echo "  Selected Functions:"
          while IFS= read -r func; do
            [[ -n "$func" ]] && echo "    - $func"
          done <<< "$selected_functions"
        fi

        if [[ -n "$selected_configurations" ]]; then
          echo "  Selected Configurations:"
          while IFS= read -r config; do
            [[ -n "$config" ]] && echo "    - $config"
          done <<< "$selected_configurations"
        fi

        echo "  Kubeconfig: {{ .KUBECONFIG_FILE }}"
        echo ""

        if [[ ! -f "{{ .KUBECONFIG_FILE }}" ]]; then
          echo "Error: Kubeconfig file not found at {{ .KUBECONFIG_FILE }}"
          exit 1
        fi

        operation="{{ .OPERATION }}"

        if gum confirm "Proceed with kubectl $operation for selected packages?"; then

          # Process Functions
          if [[ -n "$selected_functions" ]]; then
            echo ""
            echo "=== Processing Functions ==="
            while IFS= read -r function_name; do
              [[ -z "$function_name" ]] && continue

              func_url="https://raw.githubusercontent.com/stuttgart-things/crossplane/refs/heads/main/packages/functions/${function_name}.yaml"

              echo ""
              echo "Processing function: $function_name..."

              dagger call -m {{ .MODULE }}@{{ .VERSION }} kubectl \
                --operation "$operation" \
                --url-source "$func_url" \
                --kube-config file://{{ .KUBECONFIG_FILE }}

              if [[ $? -eq 0 ]]; then
                echo "‚úì Function $function_name $operation completed successfully!"
              else
                echo "‚úó Function $function_name $operation failed!"
                exit 1
              fi
            done <<< "$selected_functions"
          fi

          # Process Configurations
          if [[ -n "$selected_configurations" ]]; then
            echo ""
            echo "=== Processing Configurations ==="
            while IFS= read -r config_name; do
              [[ -z "$config_name" ]] && continue

              config_url="https://raw.githubusercontent.com/stuttgart-things/crossplane/refs/heads/main/packages/configurations/${config_name}.yaml"

              echo ""
              echo "Processing configuration: $config_name..."

              dagger call -m {{ .MODULE }}@{{ .VERSION }} kubectl \
                --operation "$operation" \
                --url-source "$config_url" \
                --kube-config file://{{ .KUBECONFIG_FILE }}

              if [[ $? -eq 0 ]]; then
                echo "‚úì Configuration $config_name $operation completed successfully!"
              else
                echo "‚úó Configuration $config_name $operation failed!"
                exit 1
              fi
            done <<< "$selected_configurations"
          fi

          echo ""
          echo "‚úì All selected packages processed successfully!"
        else
          echo "Operation cancelled."
          exit 0
        fi
