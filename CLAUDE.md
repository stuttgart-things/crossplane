# Crossplane Configurations — Project Guide

## Project Overview

This repository contains Crossplane v2 configuration packages for deploying infrastructure and applications on Kubernetes. Each configuration wraps a Helm chart or Kubernetes resource behind a declarative Crossplane API.

## Repository Structure

```
configurations/
  apps/          # Application deployments (github-controller, github-runner, ...)
  config/        # Cluster configuration
  infra/         # Infrastructure (network-integration, ...)
  k8s/           # Kubernetes resources
  terraform/     # Terraform-backed resources
docs/            # Backstage-compatible mkdocs documentation
catalog-info.yaml  # Backstage component registration
mkdocs.yml         # TechDocs configuration
```

## Configuration Module Layout (v2)

Every configuration follows this structure:

```
<name>/
  apis/definition.yaml              # XRD (apiextensions.crossplane.io/v2)
  compositions/<name>.yaml           # Composition with function-go-templating
  examples/<name>.yaml               # Example XR (uses XR kind, NOT claim kind)
  examples/functions.yaml            # Function declarations for crossplane render
  examples/provider-config.yaml      # Example ProviderConfig
  examples/configuration.yaml        # Package install manifest
  crossplane.yaml                    # Package metadata (crossplane version >=2.13.0)
  README.md                          # Must include render command
```

## Key Conventions

### XRD (definition.yaml)
- apiVersion: `apiextensions.crossplane.io/v2`
- Always include: `defaultCompositeDeletePolicy: Foreground`, `scope: Namespaced`
- Always include `targetCluster` field with `name` and `scope` (Namespaced/Cluster)
- Always include `status` schema (at minimum `installed: boolean`)
- Group: `resources.stuttgart-things.com`
- No `connectionSecretKeys` unless actually exporting secrets

### Composition
- Located in `compositions/` directory (NOT `apis/`)
- Uses `function-go-templating` (NOT `function-patch-and-transform`)
- Helm API group: `helm.m.crossplane.io/v1beta1` (NOT `helm.crossplane.io/v1beta1`)
- Use `setResourceNameAnnotation` for resource naming
- Always end with `function-auto-ready` step
- Always include status resource at end of Go template

### Function Names (must match between composition and functions.yaml)
- Go templating: `function-go-templating`
- Auto ready: `crossplane-contrib-function-auto-ready`

### crossplane.yaml
- `spec.crossplane.version: ">=2.13.0"`
- Only declare providers actually used (typically just provider-helm)

### Examples
- Example XR files MUST use the XR kind (e.g. `XGithubController`), not the claim kind
- This is required for `crossplane render` to work

## targetCluster Pattern

Every composition supports multi-cluster via:
```yaml
spec:
  targetCluster:
    name: in-cluster        # ProviderConfig name
    scope: Namespaced       # Namespaced → ProviderConfig, Cluster → ClusterProviderConfig
```

Go template scope selection:
```gotemplate
{{- $scope := $spec.targetCluster.scope | default "Namespaced" -}}
{{- $pcKind := "ProviderConfig" -}}
{{- if eq $scope "Cluster" -}}
{{- $pcKind = "ClusterProviderConfig" -}}
{{- end -}}
```

## Validation

Always validate with crossplane render:
```bash
crossplane render examples/<name>.yaml \
  compositions/<name>.yaml \
  examples/functions.yaml \
  --include-function-results
```

## Creating New Configurations — Workflow

When asked to create a new Crossplane configuration, follow this two-phase workflow:

### Phase 1: Scaffold (Claude runs dagger directly)

The scaffold is generated by calling the Dagger blueprint module directly.
Derive the naming variables from the configuration name:

- **Kind**: PascalCase of name (e.g. `gitlab-runner` → `GitlabRunner`)
- **xrdSingular**: lowercase without hyphens (e.g. `gitlabrunner`)
- **xrdPlural**: singular + `s` (e.g. `gitlabrunners`)
- **claimName**: Kind + `Claim` (e.g. `GitlabRunnerClaim`)

Run the scaffold:
```bash
dagger call -m github.com/stuttgart-things/blueprints/crossplane-configuration@v1.40.0 create \
  --name "<name>" \
  --defaults-file .configuration-defaults.yaml \
  --variables="name=<name>,kind=<Kind>,xrdSingular=<singular>,xrdPlural=<plural>,claimName=<Kind>Claim" \
  export --path="<output-folder>"
```

This generates a raw scaffold that needs structural fixes before use.

### Phase 1.5: Fix scaffold structure

The Dagger blueprint produces files with known issues. Apply these fixes:

1. **Move composition**: `apis/composition.yaml` → `compositions/<name>.yaml`
   ```bash
   mkdir -p compositions
   mv apis/composition.yaml compositions/<name>.yaml
   ```
2. **Rename example**: `examples/claim.yaml` → `examples/<name>.yaml`
3. **Fix composition**: Replace the scaffolded stub (wrong apiVersion `v1beta1`, commented-out
   pipeline referencing `function-patch-and-transform`) with a real Pipeline composition using
   `apiVersion: apiextensions.crossplane.io/v1` and `mode: Pipeline`
4. **Fix functions.yaml**: Replace wrong apiVersions and function names with:
   - `crossplane-contrib-function-go-templating` (pkg `v0.11.3`)
   - `crossplane-contrib-function-auto-ready` (pkg `v0.6.0`)
   - apiVersion for both: `pkg.crossplane.io/v1beta1`
5. **Fix example XR**: Change `apiVersion` from `v1` to `v1alpha1`, use XR kind (not claim kind)
6. **Fix README.md**: Update title and render command paths to match new file locations
7. **Add missing files**: `examples/provider-config.yaml`

### Phase 2: Fill composition logic (Claude-driven)

Once the scaffold is fixed:

1. **Read all files** in the scaffold directory
2. **Fill the composition** (`compositions/<name>.yaml`):
   - Write the go-templating inline template
   - Follow the `targetCluster` scope pattern (ProviderConfig vs ClusterProviderConfig)
   - Use `helm.m.crossplane.io/v1beta1` for Helm releases
   - Use `setResourceNameAnnotation` for resource naming
   - End the template with a status resource (`installed: true`)
   - End the pipeline with `function-auto-ready`
3. **Adjust the XRD** (`apis/definition.yaml`) — add spec properties, defaults, enums,
   descriptions for the user's requirements
4. **Update the example XR** (`examples/<name>.yaml`) to match the final schema
5. **Validate** by running:
   ```bash
   crossplane render examples/<name>.yaml \
     compositions/<name>.yaml \
     examples/functions.yaml \
     --include-function-results
   ```
6. **Fix any errors** from the render output and re-validate

### Quick reference: What the scaffold provides vs. what Claude fills in

| File | Scaffold state | Claude action |
|------|----------------|---------------|
| `apis/composition.yaml` | Wrong location, stub content | Move to `compositions/<name>.yaml`, write full pipeline |
| `apis/definition.yaml` | Skeleton (`type: object` only) | Add all spec properties for the use case |
| `examples/claim.yaml` | Wrong name, wrong apiVersion | Rename to `examples/<name>.yaml`, fix apiVersion, fill spec |
| `examples/functions.yaml` | Wrong apiVersions, wrong functions | Rewrite with correct function declarations |
| `examples/provider-config.yaml` | Missing | Create from scratch |
| `crossplane.yaml` | Complete | No changes needed |
| `README.md` | Generic title, wrong paths | Fix title and render command paths |

## Reference Module

Use `configurations/infra/network-integration/` as the canonical v2 example when creating new configurations.

## Function Versions (current)
- `function-go-templating`: v0.11.3
- `function-auto-ready`: v0.6.0
